"use client";

import type React from "react";
import { useState } from "react";

import { generate } from "@/actions/generate";
import { CandidateInfo } from "@/app/app/_components/CandidateInfo";
import { CVDisplay } from "@/app/app/_components/CvDisplay";
import "@testing-library/jest-dom";
import { fireEvent, render, screen, waitFor } from "@testing-library/react";
import { ErrorBoundary } from "react-error-boundary";

import { mockCandidateData } from "./CandidateInfo.test";

jest.mock("@/actions/generate", () => ({
  generate: jest
    .fn()
    .mockImplementation(async (cvContent, candidateInfo, user) => {
      return `
# ${candidateInfo?.name || "John Doe"}
## ${candidateInfo?.documentTitle || "Full Stack Developer"}
**Location:** ${candidateInfo?.location || "London, UK"}
**Right to Work:** ${candidateInfo?.rightToWork || "Yes"}
**Salary Expectation:** ${candidateInfo?.salaryExpectation || "Â£50,000"}
**Notes:** ${candidateInfo?.notes || "Strong background in full-stack development"}
**Generated by:** ${user?.id || "Unknown"}
      `;
    }),
}));

interface User {
  id: string;
  allowedDocs: number;
  createdDocs: number;
}

const mockedGenerate = generate as jest.MockedFunction<typeof generate>;

// test component integrates CandidateInfo and CVDisplay
function TestCVGenerator() {
  const [candidateData, setCandidateData] = useState(mockCandidateData);
  const [markdown, setMarkdown] = useState<string | undefined>(undefined);
  const [isGenerating, setIsGenerating] = useState(false);

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>,
  ) => {
    const { id, value } = e.target;
    setCandidateData((prev) => ({
      ...prev,
      [id]: value,
    }));
  };

  const handleGenerate = async () => {
    setIsGenerating(true);
    try {
      const result = await generate("Sample CV content", candidateData, {
        id: "test-user",
      } as User);
      setMarkdown(result);
    } catch (error) {
      console.error("Error generating CV:", error);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleReset = () => {
    setMarkdown(undefined);
    setCandidateData(mockCandidateData);
  };

  return (
    <div>
      {!markdown ? (
        <>
          <CandidateInfo
            candidateData={candidateData}
            onInputChange={handleInputChange}
            showNotes={false}
          />
          <button
            onClick={handleGenerate}
            disabled={isGenerating}
            data-testid="generate-button"
          >
            {isGenerating ? "Generating..." : "Generate CV"}
          </button>
        </>
      ) : (
        <CVDisplay
          markdown={markdown}
          docName={`${candidateData.name}_CV`}
          handleReset={handleReset}
        />
      )}
    </div>
  );
}

describe("CV Generator Integration", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("should show candidate form initially and generate CV when button is clicked", async () => {
    render(
      <ErrorBoundary fallback={<div>Error occurred</div>}>
        <TestCVGenerator />
      </ErrorBoundary>,
    );

    expect(screen.getByLabelText(/candidate name/i)).toBeInTheDocument();

    const generateButton = screen.getByTestId("generate-button");
    fireEvent.click(generateButton);

    await waitFor(() => {
      expect(screen.getByText(/download cv/i)).toBeInTheDocument();
      expect(screen.getByText(/reset/i)).toBeInTheDocument();
    });

    const resetButton = screen.getByText(/reset/i);
    fireEvent.click(resetButton);

    await waitFor(() => {
      expect(screen.getByLabelText(/candidate name/i)).toBeInTheDocument();
    });
  });

  it("should handle generation errors", async () => {
    (generate as jest.MockedFunction<typeof generate>).mockImplementationOnce(
      () => {
        throw new Error("Generation failed");
      },
    );

    const consoleSpy = jest.spyOn(console, "error").mockImplementation();

    render(
      <ErrorBoundary fallback={<div>Error occurred</div>}>
        <TestCVGenerator />
      </ErrorBoundary>,
    );

    const generateButton = screen.getByTestId("generate-button");
    fireEvent.click(generateButton);

    await waitFor(() => {
      expect(consoleSpy).toHaveBeenCalledWith(
        "Error generating CV:",
        expect.any(Error),
      );
    });

    expect(screen.getByLabelText(/candidate name/i)).toBeInTheDocument();

    consoleSpy.mockRestore();
  });
});

describe("generate function", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("should generate markdown content based on candidate data", async () => {
    const result = await generate("CV content", mockCandidateData, {
      id: "test-user",
    } as User);

    expect(result).toContain(mockCandidateData.name);
    expect(result).toContain(mockCandidateData.documentTitle);
    expect(result).toContain(mockCandidateData.location);
    expect(mockedGenerate).toHaveBeenCalledTimes(1);
    expect(mockedGenerate).toHaveBeenCalledWith(
      "CV content",
      mockCandidateData,
      { id: "test-user" },
    );
  });

  it("should handle errors gracefully", async () => {
    mockedGenerate.mockImplementationOnce(() => {
      return Promise.reject(new Error("Generation failed"));
    });

    await expect(
      generate("CV content", mockCandidateData, { id: "test-user" } as User),
    ).rejects.toThrow("Generation failed");
  });

  it("should return undefined when user has reached generation limit", async () => {
    mockedGenerate.mockImplementationOnce(() => Promise.resolve(undefined));

    const result = await generate("CV content", mockCandidateData, {
      id: "test-user",
      allowedDocs: 5,
      createdDocs: 5,
    } as User);

    expect(result).toBeUndefined();
  });
});
